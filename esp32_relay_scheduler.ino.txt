/*
  ESP32 8-Relay Scheduler
  - 8 relays
  - 8 schedules per relay
  - WiFi + AP fallback for configuration
  - NTP time sync (configurable timezone offset in minutes)
  - Web UI + JSON API to manage schedules and manual relay control
  - Persistent storage using Preferences (NVS)

  Dependencies:
  - ArduinoJson (install via Library Manager) 

  Author: generated for xiv3r (2026-01-31)
*/

#include <WiFi.h>
#include <WebServer.h>
#include <Preferences.h>
#include <time.h>
#include <ArduinoJson.h>

#define NUM_RELAYS 8
#define SCHEDULES_PER_RELAY 8

// Change relay pin mapping as needed
const uint8_t relayPins[NUM_RELAYS] = {16, 17, 18, 19, 21, 22, 23, 5};

// Set to true if your relay module is active HIGH, false for active LOW (typical)
const bool RELAY_ACTIVE_HIGH = false;

// NVS keys / namespaces
Preferences prefs;
const char* PREF_NAMESPACE = "relay_sched";
const char* KEY_SCHEDULES = "schedules_v1";
const char* KEY_WIFI_SSID = "wifi_ssid";
const char* KEY_WIFI_PASS = "wifi_pass";
const char* KEY_TZ_OFFSET = "tz_offset_min"; // minutes from UTC

WebServer server(80);

struct Schedule {
  bool enabled;
  uint8_t hour;
  uint8_t minute;
  uint8_t dow_mask; // bit0 = Sunday ... bit6 = Saturday
  bool state; // true = ON, false = OFF
};
Schedule schedules[NUM_RELAYS][SCHEDULES_PER_RELAY];

int relayState[NUM_RELAYS]; // current logical state (true=ON)

// last minute processed to avoid repeated triggers within same minute
int lastProcessedMinute = -1;

// Forward declarations
void startAPMode();
void handleRoot();
void handleGetSchedules();
void handlePostSchedules();
void handleStatus();
void handleToggleRelay();
void handleSaveWifi();
void saveSchedulesToPrefs();
void loadSchedulesFromPrefs();
void applyRelay(int idx, bool on);
void checkSchedules();
void connectWiFiFromPrefs();
void saveWifiToPrefs(const char* ssid, const char* pass);
void sendJSON(const String& json);
String schedulesToJson();
bool parseSchedulesJson(const String &jsonStr);
String boolToStr(bool v) { return v ? "true" : "false"; }

// Default initialization for schedules (all disabled)
void initDefaultSchedules() {
  for (int r = 0; r < NUM_RELAYS; ++r) {
    for (int s = 0; s < SCHEDULES_PER_RELAY; ++s) {
      schedules[r][s].enabled = false;
      schedules[r][s].hour = 0;
      schedules[r][s].minute = 0;
      schedules[r][s].dow_mask = 0x7F; // all days by default if enabled
      schedules[r][s].state = false;
    }
  }
}

void setup() {
  Serial.begin(115200);
  delay(100);

  // init relay pins
  for (int i = 0; i < NUM_RELAYS; ++i) {
    pinMode(relayPins[i], OUTPUT);
    relayState[i] = 0;
    applyRelay(i, false); // ensure off at start
  }

  prefs.begin(PREF_NAMESPACE, false);
  initDefaultSchedules();
  loadSchedulesFromPrefs();

  // Attempt to connect to WiFi saved in prefs
  connectWiFiFromPrefs();

  // configure server endpoints
  server.on("/", HTTP_GET, handleRoot);
  server.on("/api/schedules", HTTP_GET, handleGetSchedules);
  server.on("/api/schedules", HTTP_POST, handlePostSchedules);
  server.on("/api/status", HTTP_GET, handleStatus);
  server.on("/api/relay/toggle", HTTP_POST, handleToggleRelay); // expects JSON { "relay":0, "state": true }
  server.on("/api/savewifi", HTTP_POST, handleSaveWifi); // used in AP mode to save credentials

  server.begin();
  Serial.println("HTTP server started");

  // load timezone offset from prefs (minutes)
  int tz_offset_min = prefs.getInt(KEY_TZ_OFFSET, 0);
  // Set NTP and timezone offset; timezone is handled by applying offset to UTC time retrieving
  configTime(0, 0, "pool.ntp.org", "time.nist.gov"); // local TZ applied manually

  // wait for time sync (non-blocking with timeout)
  Serial.println("Waiting for time sync...");
  time_t now = time(nullptr);
  int retries = 0;
  while (now < 24 * 3600 && retries < 20) {
    delay(500);
    now = time(nullptr);
    retries++;
  }
  if (now >= 24 * 3600) {
    Serial.println("Time synchronized.");
  } else {
    Serial.println("Time sync failed/timed out; will continue and sync later.");
  }
}

void loop() {
  server.handleClient();

  // periodically re-sync time if necessary (ignored here, default NTP sync runs in background)
  checkSchedules();

  delay(300); // small delay to yield
}

// ---------- WiFi / AP ----------
void startAPMode() {
  const char* ap_ssid = "ESP32-Scheduler";
  const char* ap_pass = NULL; // open AP
  WiFi.mode(WIFI_AP);
  WiFi.softAP(ap_ssid);
  IPAddress ip = WiFi.softAPIP();
  Serial.print("AP mode started. Connect to WiFi SSID: ");
  Serial.print(ap_ssid);
  Serial.print(" and open http://");
  Serial.println(ip);
}

void connectWiFiFromPrefs() {
  String ssid = prefs.getString(KEY_WIFI_SSID, "");
  String pass = prefs.getString(KEY_WIFI_PASS, "");
  if (ssid.length() == 0) {
    Serial.println("No saved WiFi credentials, starting AP mode.");
    startAPMode();
    return;
  }

  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid.c_str(), pass.c_str());
  Serial.print("Connecting to WiFi SSID: ");
  Serial.println(ssid);
  int tries = 0;
  while (WiFi.status() != WL_CONNECTED && tries < 20) {
    delay(500);
    Serial.print(".");
    tries++;
  }
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println();
    Serial.print("Connected. IP: ");
    Serial.println(WiFi.localIP());
  } else {
    Serial.println();
    Serial.println("WiFi connect failed, starting AP mode.");
    startAPMode();
  }
}

void saveWifiToPrefs(const char* ssid, const char* pass) {
  prefs.putString(KEY_WIFI_SSID, ssid);
  prefs.putString(KEY_WIFI_PASS, pass);
}

// ---------- Schedules persistence ----------
void saveSchedulesToPrefs() {
  // store as binary blob
  prefs.putBytes(KEY_SCHEDULES, (const uint8_t*)schedules, sizeof(schedules));
  Serial.println("Schedules saved to NVS.");
}

void loadSchedulesFromPrefs() {
  size_t expected = sizeof(schedules);
  if (prefs.isKey(KEY_SCHEDULES)) {
    size_t stored = prefs.getBytesLength(KEY_SCHEDULES);
    if (stored == expected) {
      prefs.getBytes(KEY_SCHEDULES, (void*)schedules, expected);
      Serial.println("Schedules loaded from NVS.");
      return;
    } else {
      Serial.printf("Stored schedules size mismatch (%u != %u), resetting to defaults\n", (unsigned)stored, (unsigned)expected);
    }
  } else {
    Serial.println("No schedules in NVS, using defaults.");
  }
  // default saved for first run
  saveSchedulesToPrefs();
}

// ---------- Relay control ----------
void applyRelay(int idx, bool on) {
  if (idx < 0 || idx >= NUM_RELAYS) return;
  bool output = RELAY_ACTIVE_HIGH ? on : !on;
  digitalWrite(relayPins[idx], output ? HIGH : LOW);
  relayState[idx] = on;
  Serial.printf("Relay %d -> %s\n", idx, on ? "ON" : "OFF");
}

// ---------- Scheduler ----------
void checkSchedules() {
  time_t raw = time(nullptr);
  if (raw == (time_t)0) return; // time not yet available
  struct tm timeinfo;
  localtime_r(&raw, &timeinfo);

  // Apply timezone offset from prefs (minutes)
  int tz_offset_min = prefs.getInt(KEY_TZ_OFFSET, 0);
  if (tz_offset_min != 0) {
    raw += tz_offset_min * 60;
    localtime_r(&raw, &timeinfo);
  }

  int curMinute = timeinfo.tm_min;
  if (curMinute == lastProcessedMinute) return;
  lastProcessedMinute = curMinute;

  int curHour = timeinfo.tm_hour;
  int curDow = timeinfo.tm_wday; // 0 = Sunday

  for (int r = 0; r < NUM_RELAYS; ++r) {
    for (int s = 0; s < SCHEDULES_PER_RELAY; ++s) {
      Schedule &sc = schedules[r][s];
      if (!sc.enabled) continue;
      if (sc.hour == curHour && sc.minute == curMinute) {
        if (sc.dow_mask & (1 << curDow)) {
          // apply this schedule
          applyRelay(r, sc.state);
        }
      }
    }
  }
}

// ---------- Web endpoints ----------
void handleRoot() {
  // Simple single-page app with JS to manage schedules
  const char* html =
  R"rawliteral(
  <!doctype html>
  <html>
  <head>
    <meta charset="utf-8">
    <title>ESP32 Relay Scheduler</title>
    <style>
      body{ font-family: Arial, sans-serif; margin: 12px; }
      table{ border-collapse: collapse; width: 100%; }
      th, td{ padding: 6px; border: 1px solid #ccc; text-align:center;}
      input[type=number]{ width: 60px; }
      .relay{ margin-bottom: 16px; border: 1px solid #ddd; padding: 6px; }
      .days label { margin-right: 6px; }
      .on {color: green;} .off {color: red;}
    </style>
  </head>
  <body>
    <h2>ESP32 Relay Scheduler</h2>
    <div id="time">Time: --</div>
    <div id="relays"></div>
    <button onclick="saveAll()">Save schedules</button>
    <h3>Manual control</h3>
    <div id="manual"></div>

    <script>
      async function load() {
        await loadStatus();
        const res = await fetch('/api/schedules');
        const j = await res.json();
        buildUI(j);
      }
      function tzStr(mask) {
        let days = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
        let out = '';
        for (let i=0;i<7;i++) if (mask & (1<<i)) out += days[i]+' ';
        return out;
      }
      function buildUI(data) {
        const container = document.getElementById('relays');
        container.innerHTML = '';
        for (let r=0;r<data.relay_count;r++) {
          const div = document.createElement('div');
          div.className = 'relay';
          div.innerHTML = '<h3>Relay '+r+' - State: <span id="rs'+r+'"></span></h3>';
          const table = document.createElement('table');
          const head = document.createElement('tr');
          head.innerHTML = '<th>#</th><th>Enabled</th><th>Hour</th><th>Minute</th><th>Days</th><th>State</th>';
          table.appendChild(head);
          data.schedules[r].forEach((sc, idx) => {
            const tr = document.createElement('tr');
            tr.innerHTML = '<td>'+idx+'</td>'
                         + '<td><input type="checkbox" id="en_'+r+'_'+idx+'" '+(sc.enabled?'checked':'')+'></td>'
                         + '<td><input type="number" id="h_'+r+'_'+idx+'" min=0 max=23 value="'+sc.hour+'"></td>'
                         + '<td><input type="number" id="m_'+r+'_'+idx+'" min=0 max=59 value="'+sc.minute+'"></td>'
                         + '<td><input type="text" id="d_'+r+'_'+idx+'" value="'+sc.dow_mask+'"></td>'
                         + '<td><select id="st_'+r+'_'+idx+'"><option value=0 '+(sc.state? '':'selected')+'>OFF</option><option value=1 '+(sc.state? 'selected':'')+'>ON</option></select></td>';
            table.appendChild(tr);
          });
          div.appendChild(table);
          container.appendChild(div);
        }
        buildManualControls();
      }
      async function saveAll() {
        const res = await fetch('/api/schedules');
        const cur = await res.json();
        // gather values
        for (let r=0;r<cur.relay_count;r++) {
          for (let s=0;s<cur.schedules[r].length;s++) {
            cur.schedules[r][s].enabled = document.getElementById('en_'+r+'_'+s).checked;
            cur.schedules[r][s].hour = parseInt(document.getElementById('h_'+r+'_'+s).value) || 0;
            cur.schedules[r][s].minute = parseInt(document.getElementById('m_'+r+'_'+s).value) || 0;
            cur.schedules[r][s].dow_mask = parseInt(document.getElementById('d_'+r+'_'+s).value) || 0x7F;
            cur.schedules[r][s].state = document.getElementById('st_'+r+'_'+s).value == '1';
          }
        }
        const put = await fetch('/api/schedules', {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify(cur)
        });
        if (put.ok) alert('Saved');
      }
      async function buildManualControls() {
        const res = await fetch('/api/status');
        const j = await res.json();
        const man = document.getElementById('manual');
        man.innerHTML = '';
        for (let r=0;r<j.relay_count;r++) {
          const bOn = document.createElement('button');
          bOn.textContent = 'Relay '+r+' ON';
          bOn.onclick = async () => { await toggleRelay(r, true); await load(); };
          const bOff = document.createElement('button');
          bOff.textContent = 'Relay '+r+' OFF';
          bOff.onclick = async () => { await toggleRelay(r, false); await load(); };
          man.appendChild(bOn);
          man.appendChild(bOff);
          man.appendChild(document.createElement('br'));
        }
      }
      async function toggleRelay(rel, state) {
        await fetch('/api/relay/toggle', {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify({relay:rel, state:state})
        });
      }
      async function loadStatus(){
        const res = await fetch('/api/status');
        const j = await res.json();
        document.getElementById('time').textContent = 'Time: ' + j.time;
        for (let r=0;r<j.relay_count;r++){
          const el = document.getElementById('rs'+r);
          if (el) el.textContent = j.relay_states[r] ? 'ON' : 'OFF';
        }
      }
      setInterval(loadStatus, 5000);
      window.onload = load;
    </script>
  </body>
  </html>
  )rawliteral";

  server.sendHeader("Cache-Control", "no-cache, no-store, must-revalidate");
  server.send(200, "text/html", html);
}

void handleGetSchedules() {
  String j = schedulesToJson();
  sendJSON(j);
}

void handlePostSchedules() {
  String body = server.arg("plain");
  if (body.length() == 0) {
    server.send(400, "text/plain", "Empty body");
    return;
  }
  bool ok = parseSchedulesJson(body);
  if (!ok) {
    server.send(400, "text/plain", "Invalid JSON");
    return;
  }
  saveSchedulesToPrefs();
  server.send(200, "application/json", "{\"ok\":true}");
}

void handleStatus() {
  time_t raw = time(nullptr);
  int tz_offset_min = prefs.getInt(KEY_TZ_OFFSET, 0);
  raw += tz_offset_min * 60;
  struct tm timeinfo;
  localtime_r(&raw, &timeinfo);
  char buf[64];
  strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", &timeinfo);
  DynamicJsonDocument doc(512);
  doc["time"] = buf;
  doc["relay_count"] = NUM_RELAYS;
  JsonArray arr = doc.createNestedArray("relay_states");
  for (int i=0;i<NUM_RELAYS;i++) arr.add(relayState[i] ? 1 : 0);
  String out;
  serializeJson(doc, out);
  sendJSON(out);
}

void handleToggleRelay() {
  String body = server.arg("plain");
  if (body.length() == 0) {
    server.send(400, "text/plain", "Empty body");
    return;
  }
  DynamicJsonDocument doc(256);
  DeserializationError err = deserializeJson(doc, body);
  if (err) {
    server.send(400, "text/plain", "Invalid JSON");
    return;
  }
  int r = doc["relay"] | -1;
  bool st = doc["state"] | false;
  if (r < 0 || r >= NUM_RELAYS) {
    server.send(400, "text/plain", "Invalid relay");
    return;
  }
  applyRelay(r, st);
  server.send(200, "application/json", "{\"ok\":true}");
}

// Save WiFi credentials (used when in AP mode). JSON body { "ssid":"...", "pass":"..." }
void handleSaveWifi() {
  String body = server.arg("plain");
  if (body.length() == 0) {
    server.send(400, "text/plain", "Empty body");
    return;
  }
  DynamicJsonDocument doc(512);
  DeserializationError err = deserializeJson(doc, body);
  if (err) {
    server.send(400, "text/plain", "Invalid JSON");
    return;
  }
  const char* ssid = doc["ssid"] | "";
  const char* pass = doc["pass"] | "";
  if (strlen(ssid) == 0) {
    server.send(400, "text/plain", "SSID required");
    return;
  }
  saveWifiToPrefs(ssid, pass);
  server.send(200, "application/json", "{\"ok\":true}");
  // attempt to connect with new credentials (will disrupt AP)
  delay(200);
  connectWiFiFromPrefs();
}

// ---------- JSON helpers ----------
String schedulesToJson() {
  DynamicJsonDocument doc(16384); // big enough for schedules
  doc["relay_count"] = NUM_RELAYS;
  JsonArray relarr = doc.createNestedArray("schedules");
  for (int r = 0; r < NUM_RELAYS; ++r) {
    JsonArray slotarr = relarr.createNestedArray();
    for (int s = 0; s < SCHEDULES_PER_RELAY; ++s) {
      JsonObject o = slotarr.createNestedObject();
      o["enabled"] = schedules[r][s].enabled;
      o["hour"] = schedules[r][s].hour;
      o["minute"] = schedules[r][s].minute;
      o["dow_mask"] = schedules[r][s].dow_mask;
      o["state"] = schedules[r][s].state;
    }
  }
  String out;
  serializeJson(doc, out);
  return out;
}

bool parseSchedulesJson(const String &jsonStr) {
  DynamicJsonDocument doc(16384);
  DeserializationError err = deserializeJson(doc, jsonStr);
  if (err) {
    Serial.println("Failed to parse schedules JSON");
    Serial.println(err.c_str());
    return false;
  }
  if (!doc.containsKey("schedules")) return false;
  JsonArray relarr = doc["schedules"].as<JsonArray>();
  int r = 0;
  for (JsonVariant relv : relarr) {
    if (r >= NUM_RELAYS) break;
    JsonArray slotarr = relv.as<JsonArray>();
    int s = 0;
    for (JsonVariant sv : slotarr) {
      if (s >= SCHEDULES_PER_RELAY) break;
      JsonObject o = sv.as<JsonObject>();
      schedules[r][s].enabled = o["enabled"] | false;
      schedules[r][s].hour = (uint8_t)(o["hour"] | 0);
      schedules[r][s].minute = (uint8_t)(o["minute"] | 0);
      schedules[r][s].dow_mask = (uint8_t)(o["dow_mask"] | 0x7F);
      schedules[r][s].state = o["state"] | false;
      s++;
    }
    // if fewer slots provided, keep remaining
    r++;
  }
  // if fewer relays provided, keep remaining
  return true;
}

void sendJSON(const String& json) {
  server.sendHeader("Cache-Control", "no-cache, no-store, must-revalidate");
  server.sendHeader("Access-Control-Allow-Origin", "*");
  server.send(200, "application/json", json);
}